/*
 ============================================================================
 Name        : OS program 6 - msgQueue
 Author      : Rishab Vaishya
 SMU ID      : 47505527
 Reference1  : OS program 4
 Reference2  : https://users.cs.cf.ac.uk/Dave.Marshall/C/node25.html
 Reference3  : https://s2.smu.edu/~devans/7343/OS9epptSlides/Ch05-OS9e.pptx
 ============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>

// Number of consumer thread that the child will produce
# define ConsumerthreadsCount 3

// number of random values to generate (by default is 10)
int numberCount = 10;

// A structure of UNIX message queue
struct Message
{
	// type of message
	long mtype;

	//value of message
	int numberValue;
};

//Message queue ID
int messageQueueID;

// message Flag
int messageFlag = IPC_CREAT | 0666 | MSG_NOERROR;

// message Key
key_t messageKey = 47505527;

// instance of message struct
struct Message message;

// size of the message in the queue
size_t messageLength;

// this block will be executed by the consumers
void* ConsumerBlock(void *threadID)
{
	// sum of the consumer threads random values
	int ConsumerTotal = 0;

	// setting messsge type to 1 (1 indicates int type) 
	message.mtype = 1;

	// get consumer thread ID from param
	long consumerThreadID = (long) threadID;

	// gets the queue ID, throw an error if ID less than 0
	if ((messageQueueID = msgget(messageKey, messageFlag)) < 0)
	{
		perror("msgget");
		exit(1);
	}

	// the minimum number of loop each consumer will have to run (N/3 in our case)
	int loopCount = (numberCount / ConsumerthreadsCount);

	// the extra iteration when (N%3) != 0) will be consumed by 1st thread with thread ID : 0 
	if ((numberCount % ConsumerthreadsCount != 0) && (consumerThreadID == 0))
	{
		// increasing the loop iteration of 1st thread by number of EXTRA remaining values 
		// which are produced by producer & are to be consumed  
		loopCount = loopCount + (numberCount % ConsumerthreadsCount);
	}

	// each consumer will run the assigned number of iteration to consume the random value
	for (int i = 0; i < loopCount; i++)
	{
		// receive the message, throw an error if received byte size is less than 0 (I.E value : -1)
		if (msgrcv(messageQueueID, &message, sizeof(message.numberValue), 1, 0) < 0)
		{
			perror("msgrcv");
			exit(1);
		}

		// Adding C to a running total maintained by each consumer thread. value os C is stored in message.numberValue
		ConsumerTotal = ConsumerTotal + message.numberValue;

		// Displaying the string 
		printf("Consumer thread %d consumed : %d\n", (consumerThreadID + 1), message.numberValue);

		// Putting the consumer thread to sleep for 1-3 seconds
		sleep((rand() % 3) + 1);
	}

	// Displaying the string 
	printf("==================== > \tTotal consumed by consumer thread %d = %d\n", (consumerThreadID + 1), ConsumerTotal);

	// exiting the thread
	pthread_exit(NULL);
}

// **********************************  MAIN implementation **********************************

int main(int argc, char *argv[])
{

	// the random value generated by producer
	int randomNumber;

	// total of all random value produced by producer
	int producerTotal = 0;

	// array of cu=onsumer threads
	pthread_t Consumerthreads[ConsumerthreadsCount];

	pid_t processID;
	int status;

	// if value of N is provided by the user through command line
	if (argc == 2)
	{
		numberCount = atoi(argv[1]);
	}

	// spawn thread into parent and child thread
	processID = fork();

	// considering process with ID 0 as child process
	if (processID == 0)
	{
		for (long t = 0; t < ConsumerthreadsCount; t++)
		{
			// creating consumer threads
			pthread_create(&Consumerthreads[t], NULL, ConsumerBlock, (void *) t);
		}

		// joining all consumer threads for proper termination
		for (int i = 0; i < ConsumerthreadsCount; i++)
		{
			pthread_join(Consumerthreads[i], NULL);
		}

		// exiting thread
		pthread_exit(NULL);
	}

	// considering process with ID not equal to 0 as parent process
	else
	{
		// gets the queue ID, throw an error if ID less than 0
		if ((messageQueueID = msgget(messageKey, messageFlag)) < 0)
		{
			perror("msgget");
			exit(1);
		}

		// setting messsge type to 1 for all values (1 indicates int type) 
		message.mtype = 1;

		// parent execution loop
		for (int j = 0; j < numberCount; j++)
		{
			// generating a random number, R, in the range of 0-999.
			randomNumber = rand() % 1000;

			// assigning value (R) to message to be sent
			message.numberValue = randomNumber;

			// assigning byte size (length) for the message to be sent
			messageLength = sizeof(message.numberValue);

			// sending a message containing R, throw an error if received byte size is less than 0 (I.E value : -1)
			if (msgsnd(messageQueueID, &message, messageLength, IPC_NOWAIT) < 0)
			{
				perror("msgsnd");
				exit(1);
			}

			// adding R to a running total of all values produced
			producerTotal = producerTotal + randomNumber;

			// displaying the string
			printf("Producer produced : %d\n", randomNumber);

			// Putting the producer to sleep for 0-1 seconds
			sleep(rand() % 2);

		}
		// displaying the string
		printf("==================== > \tTotal produced by producer = %d\n", producerTotal);

		// waiting for child threads to finish
		wait(&status);

		// deleting the queue which was created
		msgctl(messageQueueID, IPC_RMID, NULL);
	}

	return 0;
}

/*
 * Explanation of how mutual exclusion and synchronization are achieved between the producer and consumers
 *
 *  These can be achieved in the following ways
 *  (reference  : https://s2.smu.edu/~devans/7343/OS9epptSlides/Ch05-OS9e.pptx)
 *
 *
 *  => Semaphore : An integer value used for signaling among processes. consists of 3 atomic operation
 *  1. initialize
 *  2. decrement - results in the blocking of a process
 *  3. increment - results in the unblocking of a process
 *  sometimes, this type of semaphore is also refered to as 'counting semaphore' or a 'general semaphor'
 *
 *  => Binary Semaphore : a type of semaphore which takes values only 0 & 1
 *
 *  => Mutex : uses locking strategy, similar to a semaphore.
 *  The process that locks the mutex (sets the value to zero) must be the one to unlock it (sets the value to 1).
 *
 *  => Condition Variable : blocks a thread till a conditions is not satisfied.
 *  Generally this condition is set to true by other concurrent threads running.
 *
 *  => Monitor : Generally used in higher level languages like JAVA, a programming language constuct that encapsulates variables, access procedures and initialization code within an abstract data type.
 *  critical sections are the access precedures which let access to the monitor 1 process at a time; this as a result can lead to a queue.
 *
 *  Event Flags : which uses memory word for synchronization. each bit hold different events associated with it in a flag.
 *  threads wait or proceed according to the bit values, thread is blocked until at least one of the bits is set.
 *
 *  => Mailboxes/Messages : A means for two processes to exchange information and that may be used for synchronization.
 *  works as a mail box which holds messages which is to be retrieved by threads 1 at a time. This is what we are using in our program
 *
 *  for UNIX messages Queue, #include <sys/msg.h>
 *  we have the following fuctions
 *
 *  msgget - creates a queue or gets the instances of queue from Queue ID
 *  msgsnd - sends message
 *  msgrcv - receives message
 *  msgctl - deletes created queue
 *
 *  => Spinlocks : Mutual exclusion mechanism in which a process executes in an infinite loop waiting for the value of a lock variable to indicate availability.
 **/

